# NTO-IRS-2025
Репозиторий решения заданий финала НТО ИРС 2025 команды "План Б -которого нет-"
Repository of solutions to the tasks of the final stage of the final stage of NTO IRS 2025 of the "План Б -которого нет-" team

**<h1>Математика робота</h1>**
Одной из главных задач для решения всех 3 этапов является управление роботом. Для управления роботом были использовали следующие методы: feed forward, двойной П-регулятор. 
Была измерена длина окружности колеса двумя различными методами: через формулу окружности, через измерение мерной лентой. В обоих случаях были получены равные значения — 14,13 см. 

> [!TIP]
> Длина окружности вычисляется по формуле: $S=2πR$.

$S=4,5 × 3,14=14,13 см$.
   
   ![5352653806854334945](https://github.com/user-attachments/assets/537c0e97-4390-45a2-9f40-221018b8a53c)
   *Рис. 1. Диаметр колеса*


Длина окружности может быть вычислена также при помощи мерной ленты.

$S=14,13 см$
   
   ![5352653806854334942](https://github.com/user-attachments/assets/22316651-d011-4050-a6a4-fdfb0f4bfb09)
   *Рис. 2. Длина окружности колеса*


Для каждого значения ШИМ (100, 150, 200) было измерено время, за которое робот проезжал 14,13 см для левого и правого колёс. Это было сделано экспериментально, используя секундомер.

| ШИМ | Левое колесо, с. | Правое колесо, с. |
| ------------- | ------------- | ------------- |
| 100 | 1,836  | 1,630  |
| 150 | 1,536  | 1,333  |
| 200 | 1,446  | 1,136  |

*Таблица 1. За какое время робот проедет 14,13 см.*

Средние значения времени в секундах были получены эмпирическим методом при помощи засекания времени трех попыток проезда робота.

Левое колесо:

| ШИМ | Первая попытка | Вторая попытка | Третья попытка |
| ------------- | ------------- | ------------- | ------------- |
| 100 | 1,90 | 1,93  | 1,68  |
| 150 | 1,66  | 1,52  | 1,43  |
| 200 | 1,71  | 1,15  | 1,48  |

*Таблица 2. Время проката левого колеса*

Правое колесо:

| ШИМ | Первая попытка | Вторая попытка | Третья попытка |
| ------------- | ------------- | ------------- | ------------- |
| 100 | 1,87 | 1,42  | 1,60  |
| 150 | 1,40  | 1,05  | 1,55  |
| 200 | 1,02  | 1,18  | 1,21  |

*Таблица 3. Время проката правого колеса*


Полученные данные были использованы для построения графика зависимости времени от ШИМ для каждого колеса. Это поможет визуально оценить, как изменяется время проезда при изменении ШИМ.
Был построен график и определены коэффициенты для двух колёс по отдельности, с помощью двух систем уравнений.
Уравнение прямой: $y=kx+b$.

<details>

<summary>Была получена формула прямой для правого колеса: $y = 0,00044x + 0,0426$, где $k=0,00044$ и $b=0,0426$</summary>

### Правое колесо:

| Дано: | Решение: |
| ------------- | ------------- |
| $S=14,13см$, $t1=1,63с$, $t2=1,3с$| $V=S/t1=0,1413/1,63=0,0866 м/с$, $V=S/t2=0,1413/1,3=0,1086 м/с$ | 


1) Координаты: (100; 0,0866)
$0,0866 = 100k + b$
3) Координаты: (150; 0,1086)
$0,1086 = 150k + b$

</details>

![image](https://github.com/user-attachments/assets/0947e333-36de-45e8-b944-cf582ed763ed)
*Рис. 3. График функции зависимости скорости от ШИМ правого колеса*


<details>

<summary>Была получена формула прямой для левого: $y = 0,00030x + 0,0470$, где $k=0,0003$ и $b=0,0470$</summary>

### Левое колесо:

| Дано: | Решение: |
| ------------- | ------------- |
| $S=14,13см$, $t1=1,836с$, $t2=1,536с$| $V=S/t1=0,1413/1,836=0,07696 м/с$, $V=S/t2=0,1413/1,536=0,0979 м/с$ | 

1) Координаты: (100; 0,77)
$0,77 = 100k + b$
3) Координаты: (150; 0,92)
$0,92 = 150k + b$

</details>

![image](https://github.com/user-attachments/assets/b100042d-54e5-421d-81f0-257caa357ca6)
*Рис. 3. График функции зависимости скорости от ШИМ левого колеса*

| Колесо | Коэффициент |
| --- | --- |
| Левое колесо | 0,00030 |
| Правое колесо | 0,00044 |

*Таблица 4. Коэффициенты колёс*


![image](https://github.com/user-attachments/assets/3faa370e-38a6-4ca1-b4cf-3d692259cdd3)
*Рис. 5. Схема коммуникации между агентами*


**<h1>управление роботом с помощью регулятора, созданного на основе функции Ляпунова<h1/>**

![image](https://github.com/user-attachments/assets/427d3946-0980-4e5c-ac82-72490a4048ae)
*Рис. 6. Схема кинематики робота*

![image](https://github.com/user-attachments/assets/31e8a5ae-e07e-4364-bcf6-5872769b1e83)
*Рис. 7. Регулятор на основе функции Ляпунова*
```
def lyapunov_calcvelocity(current_x, current_y, target_x, target_y, current_theta):
    max_speed = 255
    k2 = 10
    # Изменяем знак для Y-координаты, чтобы преобразовать в обычную систему
    normalized_x = (target_x - current_x) * 100
    normalized_y = (current_y - target_y) * 100  # Инвертируем разницу по Y
    # Дальнейшие вычисления остаются без изменений
    angle_error = math.atan2(normalized_y, normalized_x) - current_theta
    dist = (normalized_x**2 + normalized_y**2)**0.5
    linear_speed = max_speed * math.tanh(dist) * math.cos(angle_error)
    angle_speed = (max_speed * math.tanh(dist) * math.cos(angle_error) * math.sin(angle_error)) / dist + k2 * angle_error
    return [linear_speed, angle_speed]

```
	
	не использовано из-за торчащего из робоплатформы кабеля (при езде задним ходом могут быть случайные касания дргуих грузов)


**<h1>Компьютерное зрение, поиск пути и решение заданий финала </h1>**
Работа с камерой и получение заданий осуществляется по HTTP в соответствии с инструкциями предоставленными организаторами.
Нахождение внутренней матрицы камеры и коэффициентов искажения камеры осуществляется с использованием стандартных алгоритмов поиска калибровочной доски (шахматной доски 6x8, предоставленной организаторами) и методов калибровки, встроенных в OpenCV.
Сегментация осуществляется с использованием отбора HSV каналов изображения по диапазонам. 
Поиск и идентификация ArUco-маркеров реализована с использованием методов, встроенных в OpenCV.
Поиск пути реализован с помощью графа-сетки пути и алгоритма Беллмана - Форда, встроенных в NetworkX.
Поиск стереометрических ("3D") координат и их проецирование осуществляется с помощью модели камеры обскура, а также методов OpenCV (см. выдержку из документации OpenCV ниже).
Зная метрический размер ArUco-маркера можно задать координаты углов маркера, относительно центра. Зная координаты в системе координат маркера, можно найти матрицу преобразования системы координат маркера в систему координат камеры, для этого необходимо решить задачу проецирования в точку (Perspective-n-Point). Решение данной задачи реализовано в OpenCV с помощью метода `solvePnP()` (при решении исльзован методом Тоби Коллинза и Адриэна Бартоли для решения частного случая данной задачи - с компланарными точками исходной системы координат).

**<h1>Алгоритм решения Задачи№1</h1>**
1. init.py
   1.1. Сохранение изображения с пустым полем
2. main.py
   2.1. Получение задания
   2.2. Получение изображения
   2.3. Получение масок по диапазонам (выполняется один раз по изображению, полученному из 1.)
   2.4. Поиск, определение ArUco-маркеров
   2.5. Сегментация по маскам и ArUco-маркерам
   2.6. Построение графа и поиск пути пути до целевой точки
   2.7. Передача данных на роботапо UDP о положении робота и ближайшей точки пути (см 3.)
   2.8. Отображение сегментации
   2.9. Повтор 2. до окончания выполнения
3. for_RPI.py
   3.1. Получение данных по UDP о положении робота и ближайшей точки пути. 
   3.2. Движение до точки с использованием ПУ-регулятора (feed forward control)
   3.3. Повтор 3. до окончания выполнения

**<h1>Алгоритм решения Задачи№2</h1>**
1. init.py
   1.1. Сохранение изображения с пустым полем
2. main.py
   2.1. Получение задания
   2.2. Получение изображения
   2.3. Получение масок по диапазонам (выполняется один раз по изображению, полученному из 1.)
   2.4. Поиск, определение ArUco-маркеров
   2.5. Сегментация по маскам и ArUco-маркерам
   2.6. Построение графа и поиск пути пути до целевой точки для груза.
   2.7. Построение графа и поиск пути пути до точки, в которую нужно въехать роботу, чтобы сдвинуть груз в направлении ближайшей точки пути груза.
   2.8. Передача данных на роботапо UDP о положении робота и ближайшей точки пути робота (см 3.)
   2.9. Повтор 2. до окончания выполнения
3. for_RPI.py
   3.1. Получение данных по UDP о положении робота и ближайшей точки пути. 
   3.2. Движение до точки с использованием ПУ-регулятора (feed forward control)
   3.3. Повтор 3. до окончания выполнения

![image](https://github.com/user-attachments/assets/21592372-d9f4-4a50-96da-e374663f6229)
*Рис. 8. Демонстрация рещения задачи №1*

![image](https://github.com/user-attachments/assets/6e8463fa-b53d-4dc7-bfa7-f5a9311a1516)

*Рис. 9. Матрица камеры обскура*

![image](https://github.com/user-attachments/assets/d4508280-f7a1-4794-8627-53c6efef484f)

*Рис. 10.Модель камеры обскура*

P.S. @koipaqwe :+1: крутой md-файл! - я считаю, что слей :shipit:
